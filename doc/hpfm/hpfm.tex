\documentstyle{article}

\addtolength{\topmargin}{-.75in}
\addtolength{\textwidth}{1.6in}
\setlength{\textheight}{8.75in}
\addtolength{\oddsidemargin}{-0.75in}
\addtolength{\evensidemargin}{-0.75in}
\setlength{\parskip}{.1in}

\title{The PSI compiler v0.4 for HPF to Fortran 90\\User's Guide}
\author{Lenore R. Mullin, Nicole Nemer-Preece,  Scott Thibault \\
Department of Computer Science\\
University of Missouri - Rolla }

\begin{document}
\maketitle
%\tableofcontents

\section{Introduction}
The PSI Compiler is an array compiler that performs algebraic reductions on
array expressions.  The reductions eliminate unnecessary computation and 
temporary storage.  The PSI Compiler is independent of the source or 
destination language.  Thus, there has been development of different versions
of the compiler that support different languages.
This document describes the HPF to Fortran 90 version of the PSI Compiler.
Work is under way to translate subsets
of FORTRAN90, High Performance FORTRAN (HPF), and SETL into our input grammar 
for use with our compiler.  The mathematical techniques used by the compiler 
are described in the technical report ``A Reduction Semantics for Array 
Expressions: The PSI Compiler'', which is also in this distribution and
available via ftp from cs.umr.edu:tech-reports/94-05.ps.  Both the
C and HPF versions of the compiler are available via Mosaic at
http://sunserver.cs.umr.edu/~psi/psi.html

The compiler is currently available for the SUN architecture.  The 
target language of the compiler is Fortran 90, so you will need to have a
Fortran 90 compiler available to you.  The $bin/sun$ directory of this 
distribution contains
the compiler executable.  This directory needs to be added to the PATH 
environment variable or moved to a directory that already is in the PATH.  In 
order to compile the Fortran 90
programs that are generated by the compiler the module files in the 
$include$ directory need to be in one of the
directories that are searched by your Fortran 90 compiler.  

This distribution has been installed on the Computer Science Department's
file system a UMR.  In order to use the compiler on your Unix account
you will need to add /usr/local/psi/bin/sun to your PATH variable.
Also, when compiling the Fortran 90 output from the compiler you need to 
include the option -I/usr/local/psi/include.
There are some example programs in /usr/local/psi/examples/hpfm.

\section{The Language}
The input language is currently a strict subset of HPF.  
The only program unit that may be declared is the external subprogram.
Each external subprogram may contain only variable declarations of the
integer or real type and assignment statements.
The compiler parses the subprogram declarations and assignments, reduces
any applicable array expressions and outputs Fortran 90 code.  The compiler
also supports the HPF directives PROCESSORS and DISTRIBUTE.  These directives
may be used to specify abstract processor arrays and explicit distributions
for arrays.  

There is a special processor name, network, reserved for the 
PROCESSOR directive.  This processor name indicates the actual target 
platform.  Currently, network is the only platform supported.  If a processor
directive appears with the name network, it must appear at the top of the
file, it must be a one dimensional processor array and the number of processors
must be the actual number of processors in the target platform.  If the
network processor is not declared then the output program will be sequential
regardless of any DISTRIBUTE directives.  If network is declared, a distributed
program will be generated for the specified number of processors.  The
distributed program makes calls to generic message passing routines.  The
message passing routines for Fortran 90 are not available yet.

The supported subset is further restricted in the following way.  The shape
specification, that appears in the PROCESSOR directive, must contain only
integer literals.  The format clause of the DISTRIBUTE directive must also
contain only integer literals.  The array specification of an array
declaration must be an explicit shape specification and the explicit shape
specification may not have an explicit lower bound.  The CSHIFT,
DOT\_PRODUCT, EOSHIFT, MATMUL, PRODUCT, SHAPE, and SUM intrinsic array 
functions are supported.  Algebraic operators are also supported.  
Additionally,
the following two extensions for to Fortran 90 are supported (these have
been submitted to the Fortran 95 standards committee).

The language is first extended with the intrinsic function CONCAT.
The intrinsic function CONCAT is a function that concatenates the
elements of an array over any dimension.  The function is defined as follows.
\newline \begin{tabular}{ll}
CONCAT(ARRAY1,ARRAY2[,DIM]) & concatenates ARRAY1 and ARRAY2
\end{tabular} \newline
\begin{tabular}{ll}
ARRAY1 & may be of any type. \\
ARRAY2 & must be of the same type and rank as ARRAY1. \\
DIM (optional) & must be a scalar of type integer with a value in the range
$1\leq$DIM$\leq n$ \\
 & where $n$ is the rank of ARRAY1.  If DIM is omitted, the function is \\
 & operationally equivalent as if it were present with the value 1. \\
\end{tabular} \newline
The result is of the type and type parameters of ARRAY1.
If the shape of ARRAY1 is $(s1_{1},\cdots,s1_{n})$ and the shape of 
ARRAY2 is $(s2_{1},\cdots,s2_{n})$, where $n$ is the rank of ARRAY1 and ARRAY2
then 
$$s1_{1}=s2_{1},\cdots,s1_{DIM-1}=s2_{DIM-1},s1_{DIM+1}=s2_{DIM+1},\cdots,
	s1_{n}=s2_{n}$$ must be true and the shape of the result
is $(s1_{1},\cdots,s1_{DIM}+s2_{DIM},\cdots,s1_{n})$.
If $s$ is the number of elements in 
dimension DIM of ARRAY1 then
element $(i_{1},i_{2},\cdots,i_{n})$ of the result has the value of
element $(i_{1},i_{2},\cdots,i_{n})$ of ARRAY1 if $i_{DIM}\leq s$, otherwise
it has the value of element $(i_{1},\cdots,i_{DIM}-s,\cdots,i_{n})$ of
ARRAY2.

Some examples are:
If A is 
$$\left[ \begin{array}{ll}
1 & 2 \\
3 & 4 \\
5 & 6 \\
\end{array} \right] $$
and B is
$$\left[ \begin{array}{ll}
7 & 8 \\
9 & 10 \\
11 & 12 \\
\end{array} \right] $$
then CONCAT(A,B) (=CONCAT(A,B,1)) is
$$\left[ \begin{array}{ll}
1 & 2 \\
3 & 4 \\
5 & 6 \\
7 & 8 \\
9 & 10 \\
11 & 12 \\
\end{array} \right] $$
and CONCAT(A,B,2) is
$$\left[ \begin{array}{llll}
1 & 2 & 7 & 8 \\
3 & 4 & 9 & 10 \\
5 & 6 & 11 & 12 \\
\end{array} \right] $$

The second extension is the ability to index array expressions, not
just array data objects.  Any array expression can be indexed by array
subscripts or array sections using the same syntax as that of data
objects.  The Fortran 90 grammar is agumented by adding the following 
alternative to rule R701 (primary)
\begin{verbatim}
        or "(" Expr ")" [ "(" section-subscript-list ")" ]
\end{verbatim}
with the constraint: If {\it section-subscript-list} appears, the Expr must
be rank$>0$ and the number of subscripts must be equal to the rank of Expr.

The array expression must be in parenthesis and
immediately followed by the {\it section-subscript-list} also in
parenthesis as indicated by the extended rule R701.  Since an array expression 
in parenthesis is treated as a data entity, the section of an array 
expression is operationally 
equivalent to assigning the expression to a temporary array and then 
referencing the array section of the temporary indicated by
the {\it section-subscript-list}.  The shape of the temporary is 
equal to the resulting shape of the expression and has lower bounds of 1.

For example, if the shape of A,B, and C is $(2,4),(10,10),$ and
$(10,10)$ respectively then the assignment \newline
A=(B+C)(2:3,5:8) \newline
would be equivalent to the following if A,B, and C are of integer type \newline
\begin{tabular}{l}
INTEGER, DIMENSION (10,10) :: TEMP \\
\\
TEMP=B+C \\
A=TEMP(2:3,5:8) \\
\end{tabular} \newline
Note that since the compiler performs array reductions, this operation
would not be implemented by using a temporary.  For this example the
actual implementation would be \newline
\begin{tabular}{l}
A=B(2:3,5:8)+C(2:3,5:8) \\
\end{tabular} \newline

\section{Using the Compiler}
The command line format is
\begin{verbatim}
hpfm sourcefile [options] [-o | -r | -g]
\end{verbatim}
Where options one or more of the following
\begin{list}{}{}
\item[-o filename] This specifies a Fortran 90 code output filename.
\item[-g filename] This specifies a generic code output filename.  The generic
code is in MOAL but all expressions have been reduced.
\item[-r filename] This specifies a reduction transcript filename.  Provides
a transcript of the reductions that are performed on each expression.
\item[-h filename] Specifies that a host/node program should be generated
for distributed programs and filename is the name of the Fortran 90 output
of the host program.
\end{list}
If the -o, -g or -r appears at the end of the command then it may not appear
in options and it's output will be directed to the screen.  For example
\begin{verbatim}
hpfm mm.hpf -o mm.f90
\end{verbatim}
Will generate Fortran 90 code for the HPF program mm.hpf and output it to the 
file mm.f90.
\begin{verbatim}
hpfm mm.hpf -r
\end{verbatim}
Will generate a list of the reductions performed and display them on
the screen.

The Fortran 90 output may then be compiled and linked with other Fortran
90 modules using a Fortran 90 compiler.  The Fortran 90 output uses some
utility functions defined in the MOALIB module that must be linked with
the output program when compiled.  Since the compiler can only parse
external subroutines, the output will at least need to be compiled with
a module containing a main program unit.  The example makefiles for matrix 
multiply and the heat equation show how this is typically done.

Although a distributed program can be generated by the compiler, the
runtime library is not available yet for the message passing routines.
It will not be possible to compile and run distributed applications until
such a library has been made available.

\section{Future Work}
It is the intent of this project to include most of the HPF language and
support several distributed memory architectures.  Since the compiler
outputs Fortran 90, it will easily be able to support most of the HPF language.
The compiler will be able to parse and reduce array expressions and pass
any other language constructs to the output.  Several libraries will be
developed for different distributed memory architectures to support the
generic message passing mechanism of the compiler.  The first library
provided will be for a network of Unix workstations.
\end{document}
